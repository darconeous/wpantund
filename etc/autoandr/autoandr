#!/bin/bash
#
# Copyright (c) 2016 Nest Labs, Inc.
# All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# ---------------------------------------------------------------------------
#
# AUTOANDR v0.1
# =============
#
# Autoandr is a tool for easily generating `Android.mk` files for
# autotools-based projects.
#


# -- CONSTANTS --------------------------------------------------------------

AUTOANDR_VERSION=0.00.01

AUTOANDR_CFLAGS_SUFFIX=.andr_cflags
AUTOANDR_CXX_FEATURES_SUFFIX=.andr_cxxfeatures
AUTOANDR_INCLUDEPATH_SUFFIX=.andr_includes
AUTOANDR_SOURCE_SUFFIX=.andr_source

AUTOANDR_MAKE_FLAGS=

if [ -t 1 ]
then
	export ESC_BOLD=${ESC_BOLD-`printf '\033[0;1m'`}
	export ESC_NORMAL=${ESC_NORMAL-`printf '\033[0m'`}
fi

export AUTOANDR_DIR=${AUTOANDR_DIR-`cd "$(dirname $0)" && pwd`}
export SOURCE_DIR=${SOURCE_DIR-`pwd`}
export BUILD_DIR=${BUILD_DIR-${SOURCE_DIR}/etc/android}
export DESTDIR=${DESTDIR-${BUILD_DIR}/root}

export V=${V-0}

# -- FUNCS AND UTILS --------------------------------------------------------

die() {
	echo " *** ${ESC_BOLD}Fatal Error${ESC_NORMAL} $*" > /dev/stderr
	exit 1
}

show_version() {
	echo "autoandr ${AUTOANDR_VERSION}"
}

announce_pass() {
	echo " *** ${ESC_BOLD}${*}${ESC_NORMAL}"
}

announce_tool() {
	local tool=$1
	shift
	echo " * ${ESC_BOLD}${tool}${ESC_NORMAL} $*"
}

announce_path() {
	echo " ** ${ESC_BOLD}path${ESC_NORMAL} $*"
}


source_pwd() {
	echo "${SOURCE_DIR}/$(proj_pwd)"
}

library_converter() {
	while [[ $# -ge 1 ]]
	do
		case $1 in
			dbus-1) echo dbus ;;
			util) ;;
			*) echo $1 ;;
		esac
		shift
	done
}

proj_path() {
	local tmp="$*"
	tmp="${tmp#$BUILD_DIR}"
	tmp="${tmp#$SOURCE_DIR}"
	echo "${tmp#/}"
}

proj_pwd() {
	proj_path `pwd`
}

rel_path() {
	local target=$(cd `dirname "${1}"` 2>/dev/null && pwd || dirname "${1}" )/`basename "${1}"`
	local common_part=`pwd`
	local result=""

	if [[ "${target:0:1}" == "/" ]]
	then
		while [[ "${target#$common_part}" == "${target}" ]]; do
			# no match, means that candidate common part is not correct
			# go up one level (reduce common part)
			common_part="$(dirname $common_part)"
			# and record that we went back, with correct / handling
			if [[ -z $result ]]; then
				result=".."
			else
				result="../$result"
			fi
		done

		if [[ $common_part == "/" ]]; then
			# special case for root (no common path)
			result="$result/"
		fi

		# since we now have identified the common part,
		# compute the non-common part
		forward_part="${target#$common_part}"

		# and now stick all parts together
		if [[ -n $result ]] && [[ -n $forward_part ]]; then
			result="$result$forward_part"
		elif [[ -n $forward_part ]]; then
			# extra slash removal
			result="${forward_part:1}"
		fi
	else
		result="${target}"
	fi

	echo $result
}

# This function checks the arguments that would be passed to a `cc`-like
# program to see if the output is going to be an executable or an object
# file. This is needed because autotools uses `cc` as a linker when making
# executables. This function allows us to quickly determine the intent.
is_ccld() {
	while [[ $# -ge 1 ]]
	do
		case $1 in
			-c)
				return 1 # false
				;;
		esac
		shift
	done

	return 0 # true
}

# ---------------------------------------------------------------------------

androidmake_prep() {
	local parentdir

	if ! [ -f Android.mk ]
	then
		(
			echo "# File automatically generated by $(show_version)"
			echo "# \"`proj_pwd`\" - `date`"
			echo "#"
			echo
			echo 'LOCAL_PATH := $(call my-dir)'
		) > Android.mk

		localpath="$(pwd)"
		parentdir="$(cd .. && pwd)"

		if [[ "$(cd $BUILD_DIR/.. && pwd)" != "${parentdir}" ]] && [[ "${SOURCE_DIR}" != "${parentdir}" ]]
		then
			(cd .. && androidmake_prep)
			echo 'include $(NDK_PROJECT_PATH)/'$(cd ${SOURCE_DIR} && rel_path $localpath)'/Android.mk' >> ../Android.mk
		fi
	fi
}

# Arguments: <object-name> <source-file>
androidmake_object_begin() {
	ANDROIDMAKE_OBJECT_NAME=$1
	announce_tool object ${ANDROIDMAKE_OBJECT_NAME}: $(basename $2)

	echo "$2" > "${ANDROIDMAKE_OBJECT_NAME}"${AUTOANDR_SOURCE_SUFFIX}
}

# Arguments: <c-flags>
androidmake_object_cflags() {
	[ "${ANDROIDMAKE_OBJECT_NAME}" != "" ] || die "Internal error"
	echo "$*" >> "${ANDROIDMAKE_OBJECT_NAME}"${AUTOANDR_CFLAGS_SUFFIX}
}

# Arguments: <c++-features>
androidmake_object_cxx_features() {
	[ "${ANDROIDMAKE_OBJECT_NAME}" != "" ] || die "Internal error"
	echo "$*" >> "${ANDROIDMAKE_OBJECT_NAME}"${AUTOANDR_CXX_FEATURES_SUFFIX}
}

# Arguments: <header-include-paths>
androidmake_object_include_paths() {
	[ "${ANDROIDMAKE_OBJECT_NAME}" != "" ] || die "Internal error"
	echo "$*" >> "${ANDROIDMAKE_OBJECT_NAME}"${AUTOANDR_INCLUDEPATH_SUFFIX}
}

androidmake_object_end() {
	[ "${ANDROIDMAKE_OBJECT_NAME}" != "" ] || die "Internal error"
	unset ANDROIDMAKE_OBJECT_NAME
}


# Arguments: <module-name>
androidmake_module_begin() {
	ANDROIDMAKE_MODULE_NAME=$1
	androidmake_prep
	(
		echo ''
		echo "#### BEGIN ${ANDROIDMAKE_MODULE_NAME} ####"
		echo 'include $(CLEAR_VARS)'
		echo "LOCAL_MODULE := ${ANDROIDMAKE_MODULE_NAME}"
		echo 'LOCAL_MODULE_TAGS := eng'
	) >> $ANDROIDMAKE_MODULE_NAME.Android.mk
	rm -f $ANDROIDMAKE_MODULE_NAME.Android.mk.tmp || die
}

androidmake_module_link_shared_library() {
	[ "${ANDROIDMAKE_MODULE_NAME}" != "" ] || die "Internal error"
	(
		echo "LOCAL_SHARED_LIBRARIES += $1"
	) >> $ANDROIDMAKE_MODULE_NAME.Android.mk
}

androidmake_module_link_static_library() {
	[ "${ANDROIDMAKE_MODULE_NAME}" != "" ] || die "Internal error"
	(
		echo "LOCAL_STATIC_LIBRARIES += $1"
	) >> $ANDROIDMAKE_MODULE_NAME.Android.mk
}

# Arguments: <object-name>
androidmake_module_add_object() {
	[ "${ANDROIDMAKE_MODULE_NAME}" != "" ] || die "Internal error"
	object=$1
	source_file=`rel_path $(cat ${object}${AUTOANDR_SOURCE_SUFFIX})`
	(
		echo "LOCAL_SRC_FILES +=" ${source_file}
		if [ "${source_file%.cpp}" != "${source_file}" ]
		then # C++ File
			cat ${object}${AUTOANDR_CFLAGS_SUFFIX} | xargs -n 1 echo "LOCAL_CPPFLAGS +="
		else # C file
			cat ${object}${AUTOANDR_CFLAGS_SUFFIX} | xargs -n 1 echo "LOCAL_CFLAGS +="
		fi
		for includedir in $(cat ${object}${AUTOANDR_INCLUDEPATH_SUFFIX})
		do
			includedir=$(rel_path ${includedir})
			[ -z "${includedir}" ] && continue
			if [ "${includedir::1}" = "." ]
			then includedir='$(LOCAL_PATH)/'"${includedir}"
			fi
			echo "LOCAL_C_INCLUDES +=" $(rel_path ${includedir})
		done
		cat ${object}${AUTOANDR_CXX_FEATURES_SUFFIX} | xargs -n 1 echo "LOCAL_CPP_FEATURES +="
	) >> $ANDROIDMAKE_MODULE_NAME.Android.mk.tmp
}

androidmake_module_end_exec() {
	[ "${ANDROIDMAKE_MODULE_NAME}" != "" ] || die "Internal error"
	(
		sort -u $ANDROIDMAKE_MODULE_NAME.Android.mk.tmp
		echo 'include $(BUILD_EXECUTABLE)'
		echo "#### END ${ANDROIDMAKE_MODULE_NAME} ####"
	) >> $ANDROIDMAKE_MODULE_NAME.Android.mk
	rm -f $ANDROIDMAKE_MODULE_NAME.Android.mk.tmp
	#lockfile -1 -r 3 Android.mk.lock || die Lock failure
	cat $ANDROIDMAKE_MODULE_NAME.Android.mk >> Android.mk
	#rm -fr Android.mk.lock
	rm -f $ANDROIDMAKE_MODULE_NAME.Android.mk
	unset ANDROIDMAKE_MODULE_NAME
}

androidmake_module_end_shared_lib() {
	[ "${ANDROIDMAKE_MODULE_NAME}" != "" ] || die "Internal error"
	(
		sort -u $ANDROIDMAKE_MODULE_NAME.Android.mk.tmp
		echo 'include $(BUILD_SHARED_LIBRARY)'
		echo "#### END ${ANDROIDMAKE_MODULE_NAME} ####"
	) >> $ANDROIDMAKE_MODULE_NAME.Android.mk
	rm -f $ANDROIDMAKE_MODULE_NAME.Android.mk.tmp
	#lockfile -1 -r 3 Android.mk.lock || die Lock failure
	cat $ANDROIDMAKE_MODULE_NAME.Android.mk >> Android.mk
	#rm -fr Android.mk.lock
	rm -f $ANDROIDMAKE_MODULE_NAME.Android.mk
	unset ANDROIDMAKE_MODULE_NAME
}

androidmake_module_end_static_lib() {
	[ "${ANDROIDMAKE_MODULE_NAME}" != "" ] || die "Internal error"
	(
		sort -u $ANDROIDMAKE_MODULE_NAME.Android.mk.tmp
		echo 'include $(BUILD_STATIC_LIBRARY)'
		echo "#### END ${ANDROIDMAKE_MODULE_NAME} ####"
	) >> $ANDROIDMAKE_MODULE_NAME.Android.mk
	rm -f $ANDROIDMAKE_MODULE_NAME.Android.mk.tmp
	#lockfile -1 -r 3 Android.mk.lock || die Lock failure
	cat $ANDROIDMAKE_MODULE_NAME.Android.mk >> Android.mk
	#rm -fr Android.mk.lock
	rm -f $ANDROIDMAKE_MODULE_NAME.Android.mk
	unset ANDROIDMAKE_MODULE_NAME
}

# -- ARGUMENT PARSERS  ------------------------------------------------------

handle_cc() {
	if [[ ${AUTOANDR_MODE} == "make" ]]
	then (

		INCLUDE_PATHS=
		SOURCES=
		CFLAGS=
		OUTPUT=
		CXX_FEATURES=

		while [[ $# -ge 1 ]]
		do
			case $1 in
				-include)
					CFLAGS="${CFLAGS} $1 $2"
					shift
					;;

				-I*|-i*)
					INCLUDE_PATHS="${INCLUDE_PATHS} ${1:2}"
					;;

				-frtti|-fexceptions)
					CXX_FEATURES="${CXX_FEATURES} ${1:2}"
					;;

				-Werror)
					# Ignore -Werror, if present.
					;;

				-f*|-W*|-D*|-U*|-pthread|-std=*)
					CFLAGS="${CFLAGS} $1"
					;;

				-o)
					shift
					OUTPUT="$1"
					;;

				*.c|*.cpp)
					SOURCES="${SOURCES} $1"
					;;

				-g|-O[0-9]|-c)
					# Ignore these
					;;

				*)
					echo "    $# UNKNOWN \"$1\""
					;;
			esac
			shift
		done
		if [ -z "${OUTPUT}" ]
		then return 0
		fi

		androidmake_object_begin ${OUTPUT} ${SOURCES}
		androidmake_object_cflags ${CFLAGS}
		androidmake_object_cxx_features ${CXX_FEATURES}
		androidmake_object_include_paths ${INCLUDE_PATHS}
		androidmake_object_end

	) >&3
	elif [[ ${AUTOANDR_MODE} == "install" ]]
	then true
	else false
	fi
}

handle_ccld() {
	if [[ ${AUTOANDR_MODE} == "make" ]]
	then (
		OBJECTS=
		OUTPUT=
		LIBRARIES=
		STATIC_LIBRARIES=
		CFLAGS=
		while [[ $# -ge 1 ]]
		do
			case $1 in
				-o)
					shift
					OUTPUT="$1"
					;;
				-Wl*)
					# Linker stuff. Ignore for now.
					;;
				-l*)
					LIBRARIES="${LIBRARIES} ${1:2}"
					;;
				*.so)
					lib=${1:2}
					lib=$(basename ${lib%.so})
					LIBRARIES="${LIBRARIES} $lib"
					;;
				-f*|-W*|-U*|-D*|-pthread)
					CFLAGS="${CFLAGS} ${1}"
					;;
				-L*|-I*)
					# Ignore library and header search paths
					;;
				*.a)
					STATIC_LIBRARIES="${STATIC_LIBRARIES} $1"
					;;
				*.o)
					OBJECTS="${OBJECTS} $1"
					;;
				-g|-O[0-9]|-c)
					# Ignore these
					;;
				-V)
					# Version query.
					return 0
					;;
				*)
					echo "    $# UNKNOWN \"$1\""
					;;
			esac
			shift
		done

		if [ "${OUTPUT}" = "${OUTPUT%.so}" ]
		then OUTPUT_SHARED_LIBRARY=0
		else OUTPUT_SHARED_LIBRARY=1
		fi

		OUTPUT=${OUTPUT%.so}
		OUTPUT=$(basename $OUTPUT)

		announce_tool link "${OUTPUT}"

		androidmake_module_begin ${OUTPUT}
		for object in ${OBJECTS}
		do androidmake_module_add_object ${object}
		done
		for lib in $(library_converter ${LIBRARIES})
		do androidmake_module_link_shared_library lib${lib#lib}
		done
		for lib in ${STATIC_LIBRARIES}
		do androidmake_module_link_static_library $(basename ${lib%.a})
		done
		if [ "${OUTPUT_SHARED_LIBRARY}" = "1" ]
		then androidmake_module_end_shared_lib
		else androidmake_module_end_exec
		fi

	) >&3
	elif [[ ${AUTOANDR_MODE} == "install" ]]
	then true
	else false
	fi
}

handle_ar() {
	if [[ ${AUTOANDR_MODE} == "make" ]]
	then (
		OUTPUT=
		LIBRARIES=
		STATIC_LIBRARIES=
		OBJECTS=

		shift
		OUTPUT=`basename $1`
		shift
		while [[ $# -ge 1 ]]
		do
			case $1 in
				*.a)
					STATIC_LIBRARIES="${STATIC_LIBRARIES} $1"
					;;
				*.o)
					OBJECTS="${OBJECTS} $(rel_path $1)"
					;;
				*)
					echo "    $# UNKNOWN \"$1\""
					;;
			esac
			shift
		done
		if [ -z "${OUTPUT}" ]
		then return 0
		fi

		OUTPUT=${OUTPUT%.a}
		OUTPUT=$(basename $OUTPUT)

		announce_tool link-lib "${OUTPUT}"

		androidmake_module_begin ${OUTPUT}
		for object in ${OBJECTS}
		do androidmake_module_add_object ${object}
		done
		for lib in $(library_converter ${LIBRARIES})
		do androidmake_module_link_shared_library lib${lib#lib}
		done
		for lib in ${STATIC_LIBRARIES}
		do androidmake_module_link_static_library $(basename ${lib%.a})
		done
		androidmake_module_end_static_lib

	) >&3
	elif [[ ${AUTOANDR_MODE} == "install" ]]
	then true
	else false
	fi
}

handle_make() {
	if [[ ${AUTOANDR_MODE} == "make" ]]
	then
		[[ $1 == "all" ]] && (
		announce_path "$(proj_pwd)"

	) >&3
	fi
}


# -- COMMANDS ---------------------------------------------------------

autoandr_cc() {
	[ -z ${AUTOANDR_MODE} ] && die "missing mode"

	if is_ccld "$@"
	then handle_ccld "$@" || ${AUTOANDR_CC} "$@"
	else handle_cc "$@" || ${AUTOANDR_CC} "$@"
	fi
}

autoandr_cxx() {
	[ -z ${AUTOANDR_MODE} ] && die "missing mode"

	if is_ccld "$@"
	then handle_ccld "$@" || ${AUTOANDR_CXX} "$@"
	else handle_cc "$@" || ${AUTOANDR_CXX} "$@"
	fi
}

autoandr_ccld() {

	[ -z ${AUTOANDR_MODE} ] && die "missing mode"

	handle_ccld "$@" ||

	${AUTOANDR_CCLD} "$@"
}

autoandr_cxxld() {
	[ -z ${AUTOANDR_MODE} ] && die "missing mode"

	handle_ccld "$@" ||

	${AUTOANDR_CXXLD} "$@"
}

autoandr_ld() {
	[ -z ${AUTOANDR_MODE} ] && die "missing mode"

	if [[ ${AUTOANDR_MODE} == "make" ]]
	then
		echo " **" ld "$@" >&3
	fi

	${AUTOANDR_LD} "$@"
}

autoandr_cpp() {
	[ -z ${AUTOANDR_MODE} ] && die "missing mode"

	${AUTOANDR_CPP} "$@"
}

autoandr_ar() {
	[ -z ${AUTOANDR_MODE} ] && die "missing mode"

	handle_ar "$@" ||

	${AUTOANDR_AR} "$@"
}

autoandr_ranlib() {
	[ -z ${AUTOANDR_MODE} ] && die "missing mode"

	if [[ ${AUTOANDR_MODE} != "make" ]]
	then ${AUTOANDR_RANLIB} "$@"
	fi

	true
}

autoandr_make() {
	[ -z ${AUTOANDR_MODE} ] && die "missing mode"

	handle_make "$@"

	${AUTOANDR_MAKE} "$@"
}

autoandr_install() {
	[ -z ${AUTOANDR_MODE} ] && die "missing mode"

	if [[ ${AUTOANDR_MODE} == "install" ]]
	then
		announce_tool install "$*" >&3
	else
		${AUTOANDR_INSTALL} "$@"
	fi
}

# ---------------------------------------------------------------------------

autoandr_cleanup() {
	announce_pass "CLEANING UP"

	[ "${BUILD_DIR}" != "/" ] || die "Build directory is root"
	[ "${DESTDIR}" != "/" ] || die "DESTDIR is root"

	cd ${BUILD_DIR}

	find . "(" \
		-name Makefile \
		-o -name Makefile.in \
		-o -name config.status \
		-o -name .libs \
		-o -name '*.[oa]' \
		-o -name '*.[sl]o' \
		-o -name '*.la' \
		-o -name '*.dylib' \
		-o -name '.deps' \
		-o -name '.dirstamp' \
		-o -name 'stamp-h[0-9]' \
		-o -name 'config.log' \
		-o -name 'libtool' \
		-o -name '*'${AUTOANDR_CFLAGS_SUFFIX} \
		-o -name '*'${AUTOANDR_CXX_FEATURES_SUFFIX} \
		-o -name '*'${AUTOANDR_INCLUDEPATH_SUFFIX} \
		-o -name '*'${AUTOANDR_SOURCE_SUFFIX} \
		")" -print0 \
	| xargs -0 rm -rf || die

	rm -fr ${DESTDIR}
}

first() {
	echo $1
}

autoandr_start() {
	# Set up our environment

	# Maybe the root was specified with the NDK environment variable.
	[ -z "${NDK_ROOT}" ] && NDK_ROOT="${NDK}"

	# Maybe the NDK is in the path. If so, grab it via `which`.
	[ -z "${NDK_ROOT}" ] && NDK_ROOT=$(dirname `which ndk-build 2>/dev/null`)

	[ -z "${NDK_ROOT}" ] && die "\$NDK_ROOT environment variable not set!"
	[ -d "${NDK_ROOT}" ] || die "NDK root doesn't seem to exist (\"$NDK_ROOT\")"

	export NDK_ROOT
	export NDK=${NDK-$NDK_ROOT}

	export SYSROOT=${SYSROOT-$NDK/platforms/android-21/arch-arm}

	export PATH="${NDK_ROOT}:${PATH}"

	HOST=$(basename `ndk-which gcc`)
	HOST=${HOST%-gcc}

	echo NDK_ROOT=${NDK_ROOT}
	echo HOST=${HOST}

	export AUTOANDR_CC=${CC-$(ndk-which gcc) --sysroot=$SYSROOT}
	export AUTOANDR_CCLD=${CCLD-$AUTOANDR_CC}
	export AUTOANDR_AR=${AR-$(ndk-which ar)}
	export AUTOANDR_LD=${LD-$(ndk-which ld)}
	export AUTOANDR_CPP=${CPP-$(ndk-which cpp) --sysroot=$SYSROOT}
	export AUTOANDR_CXX=${CXX-$(ndk-which c++) --sysroot=$SYSROOT}
	export AUTOANDR_CXXLD=${CXXLD-$AUTOANDR_CXX}
	export AUTOANDR_MAKE=${MAKE-make}
	export AUTOANDR_INSTALL=${INSTALL-install}
	export AUTOANDR_RANLIB=${RANLIB-$(ndk-which ranlib)}

	# Make sure the build directory exists
	mkdir -p "${BUILD_DIR}" || die "Unable to create \"${BUILD_DIR}\""

	# Make sure DESTDIR exists
	mkdir -p "${DESTDIR}" || die "Unable to create \"${DESTDIR}\""

	# Make sure BUILD_DIR is absolute.
	BUILD_DIR=$(cd "${BUILD_DIR}" && pwd) || die "Unable to normalize build directory path"

	# Make sure SOURCE_DIR is absolute.
	SOURCE_DIR=$(cd "${SOURCE_DIR}" && pwd) || die "Unable to normalize source directory path"

	# Make sure DESTDIR is absolute.
	DESTDIR=$(cd "${DESTDIR}" && pwd) || die "Unable to normalize DESTDIR"

	# Sanity checks
	[ "${SOURCE_DIR::1}" == "/" ] || die "SOURCE_DIR is not an absolute path"
	[ "${BUILD_DIR::1}" == "/" ] || die "BUILD_DIR is not an absolute path"
	[ "${DESTDIR::1}" == "/" ] || die "DESTDIR is not an absolute path"
	[ "${BUILD_DIR}" != "${SOURCE_DIR}" ] || die "Build directory same as source directory"
	[ "${BUILD_DIR}" != "/" ] || die "Build directory is root"
	[ "${DESTDIR}" != "/" ] || die "DESTDIR is root"

	# Clean up our build directory
	rm -fr "${BUILD_DIR}"
	mkdir -p "${BUILD_DIR}"

	# Make a root Android.mk file
	cd "${SOURCE_DIR}" || die
	rm -f Android.mk
	androidmake_prep
	echo 'include $(LOCAL_PATH)/'$(rel_path "${BUILD_DIR}")'/Android.mk' >> ${SOURCE_DIR}/Android.mk

	cd "${BUILD_DIR}" || die

	announce_pass "CONFIGURE PASS"
	export AUTOANDR_MODE=configure
	( "${SOURCE_DIR}/configure"                    \
		CC="${AUTOANDR_DIR}/autoandr cc"         \
		CCLD="${AUTOANDR_DIR}/autoandr ccld"         \
		LD="${AUTOANDR_DIR}/autoandr ld"         \
		CPP="${AUTOANDR_DIR}/autoandr cpp"       \
		AR="${AUTOANDR_DIR}/autoandr ar"      \
		CXX="${AUTOANDR_DIR}/autoandr cxx"    \
		CXXLD="${AUTOANDR_DIR}/autoandr cxxld"    \
		MAKE="${AUTOANDR_DIR}/autoandr make"    \
		INSTALL="${AUTOANDR_DIR}/autoandr install"    \
		RANLIB="${AUTOANDR_DIR}/autoandr ranlib"    \
		--disable-dependency-tracking             \
		--with-gnu-ld \
		--host=${HOST} \
		${OTHER_CONFIGURE_FLAGS}                  \
		"$@"                                       \
	) 3>&1 1> "${AUTOANDR_STDOUT}" || die "Configure script failed"

	announce_pass "MAKE PASS"
	export AUTOANDR_MODE=make
	( autoandr_make all V=1 \
		${AUTOANDR_MAKE_FLAGS} \
		MAKE="${AUTOANDR_DIR}/autoandr make" \
		CCLD="${AUTOANDR_DIR}/autoandr ccld"         \
		CXXLD="${AUTOANDR_DIR}/autoandr cxxld"   \
	) 3>&1 1> "${AUTOANDR_STDOUT}" || die

	# Skipping install pass for now
	#
	#announce_pass "INSTALL PASS"
	#export AUTOANDR_MODE=install
	#( autoandr_make install V=1 \
	#	${AUTOANDR_MAKE_FLAGS} \
	#	DESTDIR=${DESTDIR} \
	#	MAKE="${AUTOANDR_DIR}/autoandr make" \
	#	CCLD="${AUTOANDR_DIR}/autoandr ccld"         \
	#	CXXLD="${AUTOANDR_DIR}/autoandr cxxld"    \
	#) 3>&1 1> "${AUTOANDR_STDOUT}" || die

	autoandr_cleanup

	cd ${SOURCE_DIR} || die

	marker="Added by autoandr"
	sed -i.bak "/# $marker\$/d" Makefile.in || die "Call to 'sed' failed"
	echo "EXTRA_DIST += Android.mk" $(find `rel_path "${BUILD_DIR}"` -type f) "# $marker" >> Makefile.in
}


show_help() {
	show_version
	echo ""
	echo "syntax: autoandr [general-args] <command> [command-args]"
	echo ""
	echo "General Arguments:"
	echo "    -v,--verbose .................... Verbose output"
	echo "    -V,--version .................... Print version"
	echo "    -?,-h,--help .................... Show help"
	echo ""
	echo "Commands:"
	echo ""
	echo "    start <configure-args>"
	echo "        Starts the process of building the Android.mk files."
	echo "        Must be executed from the root of the project. Any"
	echo "        arguments that you want passed to the configure script"
	echo "        should be specified after the command."
	echo ""
}

# ---------------------------------------------------------------------------

# Parse the arguments present before the command
while [[ $# -ge 1 ]]
do
	case $1 in
		-v|--verbose)
			AUTOANDR_STDOUT=/dev/stdout
			;;
		-V|--version)
			show_version
			exit 0
			;;
		-j*)
			AUTOANDR_MAKE_FLAGS="${AUTOANDR_MAKE_FLAGS} $1"
			;;
		-*)
			die "Unknown argument \"$1\""
			;;
		*)
			break
			;;
	esac
	shift
done

AUTOANDR_STDOUT=${AUTOANDR_STDOUT-/dev/null}

case $1 in
	cc)      shift ; autoandr_cc "$@" ;;
	ccld)    shift ; autoandr_ccld "$@" ;;
	ar)      shift ; autoandr_ar "$@" ;;
	ld)      shift ; autoandr_ld "$@" ;;
	cxx)     shift ; autoandr_cxx "$@" ;;
	cxxld)   shift ; autoandr_cxxld "$@" ;;
	cpp)     shift ; autoandr_cpp "$@" ;;
	make)    shift ; autoandr_make "$@" ;;
	install) shift ; autoandr_install "$@" ;;
	ranlib)  shift ; autoandr_ranlib "$@" ;;

	start)   shift ; autoandr_start "$@" ;;
	cleanup) shift ; autoandr_cleanup "$@" ;;

	*)       die "Unknown command \"$1\"" ;;
esac
